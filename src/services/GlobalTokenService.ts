import { WalletBalance } from '../domain/entities/token_entity';
import { TokenRepository } from '../domain/repositories/token_repository';
import { WalletRepository } from '../domain/repositories/wallet_repository';

/**
 * Service to√†n c·ª•c ƒë·ªÉ qu·∫£n l√Ω d·ªØ li·ªáu token v√† t·ªëi ∆∞u h√≥a API call
 */
export class GlobalTokenService {
  private static instance: GlobalTokenService;
  
  private walletBalance: WalletBalance | null = null;
  private lastFetchTime: number = 0;
  private readonly cacheValidityMs: number = 60000; // 1 ph√∫t
  private readonly tokenRepository: TokenRepository;
  private readonly walletRepository: WalletRepository;
  private listeners: Array<() => void> = [];
  private isFetching = false;
  private lastWalletAddress = '';
  
  private constructor(
    tokenRepository: TokenRepository,
    walletRepository: WalletRepository
  ) {
    this.tokenRepository = tokenRepository;
    this.walletRepository = walletRepository;
    
    // T·ª± ƒë·ªông l√†m m·ªõi cache theo ƒë·ªãnh k·ª≥
    setInterval(() => this.refreshCache(), 300000); // m·ªói 5 ph√∫t
  }
  
  /**
   * L·∫•y instance duy nh·∫•t c·ªßa GlobalTokenService
   */
  public static getInstance(
    tokenRepository?: TokenRepository,
    walletRepository?: WalletRepository
  ): GlobalTokenService {
    if (!GlobalTokenService.instance) {
      if (!tokenRepository || !walletRepository) {
        throw new Error('TokenRepository and WalletRepository are required for first initialization');
      }
      GlobalTokenService.instance = new GlobalTokenService(tokenRepository, walletRepository);
    }
    return GlobalTokenService.instance;
  }
  
  /**
   * L·∫•y d·ªØ li·ªáu s·ªë d∆∞ token, ∆∞u ti√™n t·ª´ cache n·∫øu c√≤n h·∫°n
   * @param forceRefresh B·∫Øt bu·ªôc l√†m m·ªõi d·ªØ li·ªáu t·ª´ API
   * @returns WalletBalance ho·∫∑c null n·∫øu kh√¥ng c√≥ v√≠
   */
  public async getWalletBalance(forceRefresh = false): Promise<WalletBalance | null> {
    try {
      // L·∫•y ƒë·ªãa ch·ªâ v√≠ hi·ªán t·∫°i
      const wallet = await this.walletRepository.getWallet();
      if (!wallet) return null;
      
      const now = Date.now();
      const walletAddress = wallet.address;
      
      // Ki·ªÉm tra xem ƒë·ªãa ch·ªâ v√≠ c√≥ thay ƒë·ªïi kh√¥ng
      const walletChanged = this.lastWalletAddress !== walletAddress;
      if (walletChanged) {
        this.lastWalletAddress = walletAddress;
        forceRefresh = true;
      }
      
      // Tr·∫£ v·ªÅ d·ªØ li·ªáu t·ª´ cache n·∫øu h·ª£p l·ªá
      if (
        this.walletBalance && 
        !forceRefresh && 
        (now - this.lastFetchTime < this.cacheValidityMs)
      ) {
        console.log('üì¶ GlobalTokenService: L·∫•y d·ªØ li·ªáu token t·ª´ cache (Age: ' + Math.round((now - this.lastFetchTime)/1000) + ' gi√¢y)');
        console.log('üîÑ GlobalTokenService: Th·ªùi ƒëi·ªÉm l·∫•y d·ªØ li·ªáu g·∫ßn nh·∫•t: ' + new Date(this.lastFetchTime).toLocaleTimeString());
        return this.walletBalance;
      }
      
      // Tr√°nh nhi·ªÅu request c√πng l√∫c
      if (this.isFetching) {
        console.log('‚è≥ GlobalTokenService: ƒêang c√≥ request kh√°c, ch·ªù...');
        return new Promise((resolve) => {
          const checkCache = () => {
            if (!this.isFetching) {
              resolve(this.walletBalance);
            } else {
              setTimeout(checkCache, 100);
            }
          };
          setTimeout(checkCache, 100);
        });
      }
      
      // G·ªçi API ƒë·ªÉ l·∫•y d·ªØ li·ªáu m·ªõi
      this.isFetching = true;
      console.log('üîÑ GlobalTokenService: L√†m m·ªõi d·ªØ li·ªáu token t·ª´ API');
      
      try {
        this.walletBalance = await this.tokenRepository.getWalletBalance(walletAddress);
        this.lastFetchTime = now;
        
        // Th√¥ng b√°o cho c√°c listener
        this.notifyListeners();
        return this.walletBalance;
      } catch (error) {
        console.error('‚ùå GlobalTokenService: L·ªói khi t·∫£i d·ªØ li·ªáu token', error);
        throw error;
      } finally {
        this.isFetching = false;
      }
    } catch (error) {
      console.error('‚ùå GlobalTokenService: L·ªói', error);
      return null;
    }
  }
  
  /**
   * Th√™m listener ƒë·ªÉ l·∫Øng nghe khi d·ªØ li·ªáu token ƒë∆∞·ª£c c·∫≠p nh·∫≠t
   * @param listener Function callback
   */
  public addListener(listener: () => void): void {
    if (!this.listeners.includes(listener)) {
      this.listeners.push(listener);
    }
  }
  
  /**
   * X√≥a listener
   * @param listener Function callback ƒë√£ ƒëƒÉng k√Ω
   */
  public removeListener(listener: () => void): void {
    this.listeners = this.listeners.filter(l => l !== listener);
  }
  
  /**
   * Th√¥ng b√°o cho c√°c listener r·∫±ng d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t
   */
  private notifyListeners(): void {
    this.listeners.forEach(listener => {
      try {
        listener();
      } catch (error) {
        console.error('‚ùå GlobalTokenService: L·ªói khi th√¥ng b√°o cho listener', error);
      }
    });
  }
  
  /**
   * L·∫•y d·ªØ li·ªáu s·ªë d∆∞ token t·ª´ cache ho·∫∑c ƒë·ª£i n·∫øu ƒëang c√≥ request kh√°c
   * H√†m n√†y kh√¥ng g√¢y ra API call n·∫øu kh√¥ng c·∫ßn thi·∫øt v√† s·∫Ω ƒë·ª£i d·ªØ li·ªáu t·ª´ request kh√°c
   * @param timeout Th·ªùi gian t·ªëi ƒëa ƒë·ªÉ ƒë·ª£i (ms)
   * @returns WalletBalance ho·∫∑c null n·∫øu qu√° h·∫°n
   */
  public async getWalletBalanceOrWait(timeout = 5000): Promise<WalletBalance | null> {
    try {
      // L·∫•y ƒë·ªãa ch·ªâ v√≠ hi·ªán t·∫°i
      const wallet = await this.walletRepository.getWallet();
      if (!wallet) return null;
      
      const now = Date.now();
      const walletAddress = wallet.address;
      
      // N·∫øu ƒë·ªãa ch·ªâ v√≠ thay ƒë·ªïi, c·∫ßn l√†m m·ªõi d·ªØ li·ªáu
      if (this.lastWalletAddress !== walletAddress) {
        this.lastWalletAddress = walletAddress;
        return this.getWalletBalance(true);
      }
      
      // N·∫øu ƒë√£ c√≥ d·ªØ li·ªáu trong cache v√† c√≤n h·∫°n, tr·∫£ v·ªÅ ngay
      if (this.walletBalance && (now - this.lastFetchTime < this.cacheValidityMs)) {
        console.log('üì¶ GlobalTokenService: L·∫•y d·ªØ li·ªáu token t·ª´ cache (Age: ' + Math.round((now - this.lastFetchTime)/1000) + ' gi√¢y)');
        return this.walletBalance;
      }
      
      // N·∫øu ƒëang fetch, ƒë·ª£i ho√†n th√†nh
      if (this.isFetching) {
        console.log('‚è≥ GlobalTokenService: getWalletBalanceOrWait ƒëang ch·ªù d·ªØ li·ªáu ƒë∆∞·ª£c fetch b·ªüi request kh√°c...');
        return new Promise((resolve) => {
          let timeoutId: NodeJS.Timeout;
          
          // T·∫°o listener t·∫°m th·ªùi
          const tempListener = () => {
            clearTimeout(timeoutId);
            this.removeListener(tempListener);
            resolve(this.walletBalance);
          };
          
          this.addListener(tempListener);
          
          // Timeout safety
          timeoutId = setTimeout(() => {
            this.removeListener(tempListener);
            console.log('‚åõ GlobalTokenService: H·∫øt th·ªùi gian ch·ªù, tr·∫£ v·ªÅ d·ªØ li·ªáu hi·ªán c√≥');
            resolve(this.walletBalance); // Tr·∫£ v·ªÅ d·ªØ li·ªáu hi·ªán c√≥, k·ªÉ c·∫£ null
          }, timeout);
        });
      }
      
      // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu v√† kh√¥ng ai ƒëang fetch, b·∫Øt ƒë·∫ßu fetch m·ªõi
      console.log('üîÑ GlobalTokenService: Kh√¥ng c√≥ d·ªØ li·ªáu trong cache v√† kh√¥ng c√≥ request ƒëang ch·ªù, b·∫Øt ƒë·∫ßu fetch m·ªõi');
      return this.getWalletBalance(false);
    } catch (error) {
      console.error('‚ùå GlobalTokenService: L·ªói trong getWalletBalanceOrWait', error);
      return this.walletBalance; // Tr·∫£ v·ªÅ d·ªØ li·ªáu hi·ªán c√≥, k·ªÉ c·∫£ null
    }
  }
  
  /**
   * L√†m m·ªõi cache (sau giao d·ªãch ho·∫∑c khi c·∫ßn)
   */
  public async refreshCache(): Promise<void> {
    await this.getWalletBalance(true);
  }
  
  /**
   * L√†m m·ªõi cache sau khi ho√†n th√†nh giao d·ªãch
   * @param transactionHash Hash c·ªßa giao d·ªãch v·ª´a ho√†n th√†nh
   */
  public async refreshAfterTransaction(transactionHash: string): Promise<void> {
    console.log(`üîÑ GlobalTokenService: L√†m m·ªõi d·ªØ li·ªáu sau giao d·ªãch ${transactionHash}`);
    
    // ƒê·ª£i m·ªôt ch√∫t ƒë·ªÉ blockchain c·∫≠p nh·∫≠t s·ªë d∆∞
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    // L√†m m·ªõi cache
    return this.refreshCache();
  }
}
